---

- name: Read or Create a new prefix id for ct
  shell: /bin/sh -c '( grep -e ":{{ ctName }}:" {{ lxcIdsMapFile }} | grep -Eo -e "^[0-9]+" ) || ( prefixId=$(( $(tail -1 {{ lxcIdsMapFile }} | grep -Eo -e "^[0-9]+" || echo 9) + 1 )) && echo "$prefixId:{{ ctName }}:" >> {{ lxcIdsMapFile }} && echo $prefixId )'
  become: yes
  register: result

- name: Generate deterministic mac address
  set_fact: 
    staticIpAvailable: true
    ctDeterministicMacAddress: "{{ ctName | hash('sha1') | regex_replace('^(..)(..)(..)(..).*', '00:ff:\\1:\\2:\\3:\\4') }}"
    ctPrefixId: "{{ result.stdout }}"

- debug: var=ctDeterministicMacAddress

- name: Create lxc specific config file
  template:
    src: lxc_container.conf.j2
    dest: "{{ tmpLxcConfigFile }}"
    owner: "{{ lxcUser }}"
    group: "{{ lxcUser }}"
    mode: 0400
  become: yes

- name: List volume directories from container config file
  shell: /bin/sh -c "grep -e '^\s*lxc.mount.entry' {{ tmpLxcConfigFile }} | sed -re 's/^\s*lxc.mount.entry\s*=\s*(.*)/\1/' | cut -d' ' -f1-2 | tr ' ' '\n'"
  become: yes
  register: volumeDirs
  changed_when: no

#- debug: var=volumeDirs

# Read volumes directories from lxc config files
- name: Create volumes directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ lxcUser }}"
    group: "{{ lxcUser }}"
    mode: 0777
  with_items: "{{ volumeDirs.stdout_lines }}"
  when: volumeDirs.stdout_lines | length > 0
  become: yes

- name: Create new container named {{ ctName }} and start it
  lxc_container:
    name: "{{ ctName }}"
    config: "{{ tmpLxcConfigFile }}"
    backing_store: dir
    container_log: true
    container_log_level: DEBUG
    state: started
    template: download
    template_options: --dist {{ distribName }} --release {{ distribRelease }} --arch amd64
    #lxc_path: "{{lxcVolPath}}"
    #directory: "{{lxcVolPath}}/{{ctName}}/rootfs"
    #fs_type: ext4
    #fs_size: 1G
  notify: 
    - Wait for ping
  become: yes
  become_user: "{{ lxcUser }}"

- name: Create container groups config file
  file:
    path: "{{ lxcAnsibleGroupsFile }}"
    state: touch
  become: yes
  become_user: "{{ lxcUser }}"

- name: Remove lxc config file
  file:
    path: "{{ tmpLxcConfigFile }}"
    state: absent
  become: yes

- name: Initialize Alpine container
  shell: "lxc-attach -n {{ ctName }} --clear-env -e -- /bin/sh -c 'su -; udchpd -R; {{ proxyConfig }} apk update -q; apk upgrade -q; apk add -q openssh python2 sudo; id {{ provisioningUser }} || adduser -u {{ provisioningUserUid }} -D {{ provisioningUser }}; rc-update add sshd; /etc/init.d/sshd start'"
  register: ctInitMsg
  #failed_when: ctInitMsg.stderr != ''
  until:  ctInitMsg | succeeded
  become: yes
  become_user: "{{ lxcUser }}"
  retries: 2
  delay: 3
  when: distribName == "alpine"
  tags: init

- name: Initialize Debian container
  shell: "lxc-attach -n {{ ctName }} --clear-env -e -- /bin/sh -c 'su -; ip addr show | grep 10.0.3.0 && ip addr del 10.0.3.0 dev eth0 && dhclient -r; sleep 1 && dhclient; {{ proxyConfig }} apt update -q -y --force-yes; apt upgrade -q -y --force-yes; apt install -q -y --force-yes ssh python2.7 sudo; test -f /usr/bin/python || ln -s /usr/bin/python2.7 /usr/bin/python; id {{ provisioningUser }} || adduser --uid {{ provisioningUserUid }} --disabled-password {{ provisioningUser }}; update-rc.d ssh defaults; /etc/init.d/ssh start'"
  register: ctInitMsg
  #failed_when: ctInitMsg.stderr != ''
  until:  ctInitMsg | succeeded
  become: yes
  become_user: "{{ lxcUser }}"
  retries: 2
  delay: 3
  when: distribName == "debian" or distribName == "ubuntu"
  tags: init

- name: Initialize container
  shell: "lxc-attach -n {{ ctName }} --clear-env -e -- /bin/sh -c 'su -; passwd -u {{ provisioningUser }}; echo \"manager ALL=(ALL) NOPASSWD:ALL\" > /etc/sudoers.d/manager; test -d /home/{{ provisioningUser }}/.ssh || mkdir /home/{{ provisioningUser }}/.ssh; echo \"{{ provisioningPubKey }}\" > /home/{{ provisioningUser }}/.ssh/authorized_keys; chown -R {{ provisioningUser }}:{{ provisioningUser }} /home/{{ provisioningUser }}; chmod 700 /home/{{ provisioningUser }}/.ssh; chmod 600 /home/{{ provisioningUser }}/.ssh/authorized_keys;'"
  register: ctInitMsg
  #failed_when: ctInitMsg.stderr != ''
  until:  ctInitMsg | succeeded
  become: yes
  become_user: "{{ lxcUser }}"
  retries: 2
  delay: 3
  when: distribName == "debian" or distribName == "ubuntu" or distribName == "alpine"
  tags: init

- name: Discover CT IP
  import_tasks: discover_ct_ip.yml

- name: Config dnsmasq to fix container IP
  lineinfile:
    path: /etc/lxc/dnsmasq-hosts.conf
    regexp: "^{{ ctName }}"
    line: "{{ ctName }},{{ discoveredCtIp }}"
  become: yes
  notify:
    - Reload dnsmasq config
    - Add CT to inventory

- name: Check IP is corretly assigned
  assert:
    that: discoveredCtIp == ctIp
  register: result
  changed_when: result | failed
  failed_when: no
  notify: 
    - Reload dnsmasq config
    - Restart lxc container
  when: staticIpAvailable and ctIp is defined
  
- name: Add container groups in config file
  lineinfile:
    path: "{{ lxcAnsibleGroupsFile }}"
    regexp: "^{{ ctName }}:"
    line: "{{ ctName }}:lxc,{{ ctGroups | join(',') }}"
  become: yes
  become_user: "{{ lxcUser }}"


# Use shell to interact with iptables because iptables modules is not idempotent
- name: Remove previous iptables DNAT rules
  shell: "iptables -t nat -S PREROUTING | grep DNAT | grep -v '{{ discoveredCtIp }}' | cut -d' ' -f2- | while read rule; do deleteCmd=\"iptables -t nat -D $rule\"; echo $deleteCmd; /bin/sh -c \"$deleteCmd\"; done"
  register: result
  changed_when: result.stdout != ""
  notify: 
    - Save iptables rules
  become: yes

- name: Configure iptables to forward traffic
  shell: "iptables -t nat -S PREROUTING | grep -e '-d {{ lxcHostIp }}/32 -p tcp -m tcp --dport {{ item.key }} -j DNAT --to-destination {{ discoveredCtIp }}:{{ item.value }}' || iptables -t nat -A PREROUTING -d {{ lxcHostIp }}/32 -p tcp -m tcp --dport {{ item.key }} -j DNAT --to-destination {{ discoveredCtIp }}:{{ item.value }}"
  register: result
  changed_when: result.stdout == ""
  become: yes
  with_dict: "{{ ctPortsMapping }}"
  notify: 
    - Save iptables rules
  when: ctPortsMapping is defined

- name: Flush handlers
  meta: flush_handlers

# vi: tabstop=2 expandtab shiftwidth=2 softtabstop=2
